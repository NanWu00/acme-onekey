#!/usr/bin/env bash
# optimize-node.sh
# One-shot optimizer for high-bandwidth proxy nodes (Debian/Ubuntu/CentOS/RHEL/Alma/Rocky...)
# - Detects primary network interface, CPU count, package manager
# - Applies sysctl network tuning optimized for BBR + fq
# - Enables ethtool features (GRO/GSO/TSO), attempts multiqueue
# - Rebalances IRQs across CPUs
# - Sets fq qdisc, persists via systemd service to reapply on boot
# - Enables CPU performance governor if available
# - Increases ulimit and connection-related kernel params
#
# Run as root:
#   sudo bash optimize-node.sh
#
set -euo pipefail
SCRIPTDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TIMESTAMP="$(date +%Y%m%d_%H%M%S)"
BACKUP_DIR="/root/optimize-node-backups-${TIMESTAMP}"
mkdir -p "${BACKUP_DIR}"

# Helper: print and log
log() { echo -e "[OPTIMIZE] $*"; }

if [ "$(id -u)" -ne 0 ]; then
  echo "This script must be run as root. Use sudo." >&2
  exit 1
fi

# Detect package manager
if command -v apt-get >/dev/null 2>&1; then
  PKG="apt"
elif command -v dnf >/dev/null 2>&1; then
  PKG="dnf"
elif command -v yum >/dev/null 2>&1; then
  PKG="yum"
elif command -v zypper >/dev/null 2>&1; then
  PKG="zypper"
else
  PKG=""
fi

log "Detected package manager: ${PKG:-none}"

# Install small utilities if available
install_pkgs() {
  case "$PKG" in
    apt)
      apt-get update -y
      DEBIAN_FRONTEND=noninteractive apt-get install -y ethtool iproute2 iftop htop sysstat irqbalance || true
      ;;
    dnf)
      dnf install -y ethtool iproute iftop htop sysstat irqbalance || true
      ;;
    yum)
      yum install -y ethtool iproute iftop htop sysstat irqbalance || true
      ;;
    zypper)
      zypper install -y ethtool iproute2 iftop htop sysstat irqbalance || true
      ;;
    *)
      log "No supported package manager found; skipping package install."
      ;;
  esac
}

install_pkgs

# Detect primary interface via route to public DNS
PRIMARY_IFACE="$(ip route get 8.8.8.8 2>/dev/null | awk '/dev/ {for(i=1;i<=NF;i++){if($i=="dev"){print $(i+1); exit}}}')"
if [ -z "$PRIMARY_IFACE" ]; then
  # fallback: first non-loopback up interface
  PRIMARY_IFACE="$(ip -o link show | awk -F': ' '{print $2}' | grep -v lo | head -n1)"
fi

if [ -z "$PRIMARY_IFACE" ]; then
  echo "Could not detect primary network interface. Exiting." >&2
  exit 1
fi

log "Primary network interface detected: ${PRIMARY_IFACE}"

# Determine CPU count
CPU_COUNT="$(nproc --all)"
log "CPU cores: ${CPU_COUNT}"

# Backup important files
backup_file_if_exists() {
  local f="$1"
  if [ -e "$f" ]; then
    mkdir -p "${BACKUP_DIR}/etc"
    cp -a "$f" "${BACKUP_DIR}/$(basename "$f").${TIMESTAMP}.bak"
    log "Backed up $f -> ${BACKUP_DIR}/$(basename "$f").${TIMESTAMP}.bak"
  fi
}

backup_file_if_exists /etc/sysctl.conf

# Create sysctl drop-in
SYSCTL_DROPIN="/etc/sysctl.d/99-optimizations.conf"
if [ -e "$SYSCTL_DROPIN" ]; then
  backup_file_if_exists "$SYSCTL_DROPIN"
fi

cat > "${SYSCTL_DROPIN}" <<'EOF'
# /etc/sysctl.d/99-optimizations.conf
# Generated by optimize-node.sh
# Use fq for BBR pacing and enlarge TCP buffers for high-BDP links
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr

# TCP buffers
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864

# Connection handling
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 10
net.core.somaxconn = 65535
net.core.netdev_max_backlog = 250000
net.ipv4.tcp_max_syn_backlog = 8192
net.ipv4.tcp_mtu_probing = 1

# Increase entropy for servers (optional)
# net.ipv4.tcp_synack_retries = 2
EOF

log "Wrote sysctl drop-in to ${SYSCTL_DROPIN}"
log "Applying sysctl..."
sysctl --system >/dev/null 2>&1 || true

# Check BBR availability
if sysctl net.ipv4.tcp_congestion_control | grep -q bbr; then
  log "BBR set in kernel params."
else
  # Try to enable bbr (if kernel supports)
  if grep -q "bbr" /boot/config-* 2>/dev/null || zgrep -q "CONFIG_TCP_CONG_BBR" /proc/config.gz 2>/dev/null || ls /lib/modules/$(uname -r)/kernel/net/ipv4/tcp* 2>/dev/null | grep -q bbr; then
    log "BBR support appears present; setting sysctl again."
    sysctl -w net.ipv4.tcp_congestion_control=bbr || true
  else
    log "Warning: kernel may not support BBR. Skipping enabling BBR; please upgrade kernel if needed."
  fi
fi

# Apply fq qdisc immediately
if command -v tc >/dev/null 2>&1; then
  log "Setting qdisc fq on ${PRIMARY_IFACE}"
  tc qdisc replace dev "${PRIMARY_IFACE}" root fq || log "tc qdisc replace failed (you may need iproute2 / tc installed or run on supported kernel)."
else
  log "tc command not found; skipping immediate qdisc set."
fi

# Ethtool tuning: GRO/GSO/TSO and try to set combined queues
if command -v ethtool >/dev/null 2>&1; then
  # Enable offloads if supported
  log "Querying ethtool features for ${PRIMARY_IFACE}..."
  ethtool -k "${PRIMARY_IFACE}" || true
  for feat in gro gso tso; do
    ethtool -K "${PRIMARY_IFACE}" ${feat} on || log "Failed to enable ${feat} on ${PRIMARY_IFACE} (may be unsupported)"
  done

  # Try to set combined queues (multiqueue) to min(cpu_count, max_supported)
  if ethtool -l "${PRIMARY_IFACE}" >/dev/null 2>&1; then
    MAX_COMBINED=$(ethtool -l "${PRIMARY_IFACE}" 2>/dev/null | awk '/Combined:/ {print $2}')
    if [ -n "${MAX_COMBINED}" ] && [ "${MAX_COMBINED}" -gt 0 ]; then
      TARGET=$(( CPU_COUNT > MAX_COMBINED ? MAX_COMBINED : CPU_COUNT ))
      log "Attempting to set combined queues of ${PRIMARY_IFACE} -> ${TARGET} (max ${MAX_COMBINED})"
      ethtool -L "${PRIMARY_IFACE}" combined "${TARGET}" || log "ethtool -L failed or unsupported on this interface"
    fi
  fi
else
  log "ethtool not installed; skipping NIC offload tuning."
fi

# Configure irq affinity: distribute network IRQs across available CPUs
log "Attempting to rebalance IRQs for ${PRIMARY_IFACE}..."
INTS=$(grep -n "${PRIMARY_IFACE}" /proc/interrupts 2>/dev/null || true)
if [ -n "${INTS}" ]; then
  # Build bitmask round-robin across CPUs
  # We'll create masks like 1,2,4,8,... or spread across CPU_COUNT
  cpu_masks=()
  for ((i=0;i<CPU_COUNT;i++)); do
    # compute hex mask with single bit set
    mask=$(printf "%x" $((1<<i)))
    cpu_masks+=("${mask}")
  done
  # iterate interrupt lines and assign masks cyclically
  idx=0
  echo "${INTS}" | while read -r line; do
    irqnum=$(echo "$line" | awk -F: '{print $1}')
    mask=${cpu_masks[$((idx % ${#cpu_masks[@]}))]}
    if [ -e "/proc/irq/${irqnum}/smp_affinity" ]; then
      echo "${mask}" > /proc/irq/${irqnum}/smp_affinity || log "Failed to write smp_affinity for IRQ ${irqnum}"
      log "IRQ ${irqnum} -> mask 0x${mask}"
    fi
    idx=$((idx+1))
  done
else
  log "No IRQ lines referencing ${PRIMARY_IFACE} found in /proc/interrupts. Skipping IRQ rebalancing."
fi

# CPU governor: try to set 'performance'
set_cpu_perf() {
  if command -v cpufreq-set >/dev/null 2>&1; then
    log "Setting cpufreq governor to performance via cpufrequtils"
    for cpu in /sys/devices/system/cpu/cpu[0-9]*; do
      govfile="${cpu}/cpufreq/scaling_governor"
      if [ -w "${govfile}" ]; then
        echo performance > "${govfile}" || true
      fi
    done
  else
    # direct sysfs method
    if [ -d /sys/devices/system/cpu ]; then
      for g in /sys/devices/system/cpu/cpu[0-9]*; do
        if [ -w "${g}/cpufreq/scaling_governor" ]; then
          echo performance > "${g}/cpufreq/scaling_governor" || true
        fi
      done
    fi
  fi
}
set_cpu_perf || log "Failed to set CPU governor to performance (may be unsupported by cloud provider)."

# Increase open file limits (system-wide)
LIMITS_FILE="/etc/security/limits.conf"
backup_file_if_exists "${LIMITS_FILE}"
cat >> "${LIMITS_FILE}" <<'EOF'

# Added by optimize-node.sh - increase file descriptors
*               soft    nofile          1000000
*               hard    nofile          1000000
EOF

log "Appended ulimit settings to ${LIMITS_FILE}."

# For systemd-managed services, create a drop-in preset to increase DefaultLimitNOFILE
if command -v systemctl >/dev/null 2>&1; then
  mkdir -p /etc/systemd/system.conf.d
  SYSTEMD_DROPIN="/etc/systemd/system.conf.d/90-optimizations.conf"
  if [ -e "${SYSTEMD_DROPIN}" ]; then
    backup_file_if_exists "${SYSTEMD_DROPIN}"
  fi
  cat > "${SYSTEMD_DROPIN}" <<'EOF'
[Manager]
DefaultLimitNOFILE=1000000
EOF
  log "Wrote systemd manager drop-in to ${SYSTEMD_DROPIN}"
  systemctl daemon-reload || true
fi

# Persist network tunings (ethtool, tc qdisc, irq affinity) via a systemd service + script
SERVICE_SCRIPT="/usr/local/sbin/network-optimize-apply.sh"
backup_file_if_exists "${SERVICE_SCRIPT}"
cat > "${SERVICE_SCRIPT}" <<EOF
#!/usr/bin/env bash
# network-optimize-apply.sh - apply NIC tuning on boot
IF="${PRIMARY_IFACE}"
CPU_COUNT=${CPU_COUNT}
# apply ethtool offloads
if command -v ethtool >/dev/null 2>&1; then
  ethtool -K "\${IF}" gro on gso on tso on || true
  # try multiqueue: set combined = min(cpu_count, max_combined)
  if ethtool -l "\${IF}" >/dev/null 2>&1; then
    MAX=\$(ethtool -l "\${IF}" 2>/dev/null | awk '/Combined:/ {print \$2}')
    if [ -n "\${MAX}" ] && [ "\${MAX}" -gt 0 ]; then
      TARGET=\$(( CPU_COUNT > MAX ? MAX : CPU_COUNT ))
      ethtool -L "\${IF}" combined "\${TARGET}" || true
    fi
  fi
fi

# set qdisc
if command -v tc >/dev/null 2>&1; then
  tc qdisc replace dev "\${IF}" root fq || true
fi

# restore IRQ masks from current state (best-effort)
# (no persistent masks stored; best-effort re-run of simple distribution)
INTS=\$(grep -n "\${IF}" /proc/interrupts 2>/dev/null || true)
if [ -n "\${INTS}" ]; then
  masks=()
  for ((i=0;i<CPU_COUNT;i++)); do
    masks+=(\$(printf "%x" $((1<<i))))
  done
  idx=0
  echo "\${INTS}" | while read -r line; do
    irqnum=\$(echo "\$line" | awk -F: '{print \$1}')
    if [ -e "/proc/irq/\${irqnum}/smp_affinity" ]; then
      echo "\${masks[\$((idx % \${#masks[@]}))]}" > /proc/irq/\${irqnum}/smp_affinity || true
    fi
    idx=\$((idx+1))
  done
fi
EOF

chmod +x "${SERVICE_SCRIPT}"
log "Wrote network apply script to ${SERVICE_SCRIPT}"

SYSTEMD_UNIT="/etc/systemd/system/network-optimize.service"
backup_file_if_exists "${SYSTEMD_UNIT}"
cat > "${SYSTEMD_UNIT}" <<EOF
[Unit]
Description=Apply network optimizations (ethtool/tc/irq) at boot
After=network.target

[Service]
Type=oneshot
ExecStart=${SERVICE_SCRIPT}
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload || true
systemctl enable --now network-optimize.service || log "Failed to enable/start network-optimize.service (platform may restrict)"

# Final messages and diagnostics
log "===== DIAGNOSTIC SUMMARY ====="
log "Primary interface: ${PRIMARY_IFACE}"
log "- sysctl drop-in: ${SYSCTL_DROPIN}"
log "- network apply script: ${SERVICE_SCRIPT}"
log "- systemd unit: ${SYSTEMD_UNIT}"

# show current qdisc
if command -v tc >/dev/null 2>&1; then
  log "tc qdisc show for ${PRIMARY_IFACE}:"
  tc qdisc show dev "${PRIMARY_IFACE}" || true
fi

# show ethtool -k
if command -v ethtool >/dev/null 2>&1; then
  log "ethtool -k ${PRIMARY_IFACE}:"
  ethtool -k "${PRIMARY_IFACE}" || true
fi

log "Backups saved to ${BACKUP_DIR}"
log "If you use systemd and run services for proxies (xray/sing-box), consider adding service-specific LimitNOFILE and CPU affinity in their systemd service drop-ins."
log "Reboot is not required, but a reboot will ensure all changes (systemd manager limits, CPU governor, systemd service) are fully applied."
log "===== END ====="

exit 0
